{"ast":null,"code":"import * as i0 from \"@angular/core\";\nexport class HoverCardDirective {\n  constructor(el, renderer) {\n    this.el = el;\n    this.renderer = renderer;\n    this.hoverScale = '1.02';\n    this.hoverRotateX = '0deg';\n    this.hoverRotateY = '0deg';\n    this.transitionDuration = '0.3s';\n    this.perspective = '1000px';\n    this.shadowColor = 'rgba(0, 0, 0, 0.1)';\n    // Store initial styles\n    this.initialTransform = this.el.nativeElement.style.transform || '';\n    this.initialTransition = this.el.nativeElement.style.transition || '';\n    this.initialBoxShadow = this.el.nativeElement.style.boxShadow || '';\n    // Set initial perspective\n    this.renderer.setStyle(this.el.nativeElement, 'perspective', this.perspective);\n    this.renderer.setStyle(this.el.nativeElement, 'transition', `all ${this.transitionDuration} ease`);\n  }\n  onMouseEnter(event) {\n    // Calculate tilt based on mouse position\n    const rect = this.el.nativeElement.getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    const y = event.clientY - rect.top;\n    // Calculate rotation (subtle effect)\n    const rotateY = (x / rect.width - 0.5) * 5; // -2.5 to 2.5 degrees\n    const rotateX = (y / rect.height - 0.5) * -5; // 2.5 to -2.5 degrees\n    // Apply transform\n    this.renderer.setStyle(this.el.nativeElement, 'transform', `${this.initialTransform} scale(${this.hoverScale}) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`);\n    // Apply enhanced shadow\n    this.renderer.setStyle(this.el.nativeElement, 'box-shadow', `0 10px 25px -5px ${this.shadowColor}, 0 10px 10px -5px ${this.shadowColor}`);\n  }\n  onMouseMove(event) {\n    // Calculate tilt based on mouse position\n    const rect = this.el.nativeElement.getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    const y = event.clientY - rect.top;\n    // Calculate rotation (subtle effect)\n    const rotateY = (x / rect.width - 0.5) * 5; // -2.5 to 2.5 degrees\n    const rotateX = (y / rect.height - 0.5) * -5; // 2.5 to -2.5 degrees\n    // Apply transform\n    this.renderer.setStyle(this.el.nativeElement, 'transform', `${this.initialTransform} scale(${this.hoverScale}) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`);\n  }\n  onMouseLeave() {\n    // Reset transform\n    this.renderer.setStyle(this.el.nativeElement, 'transform', this.initialTransform);\n    // Reset shadow\n    this.renderer.setStyle(this.el.nativeElement, 'box-shadow', this.initialBoxShadow);\n  }\n  static {\n    this.ɵfac = function HoverCardDirective_Factory(t) {\n      return new (t || HoverCardDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n    };\n  }\n  static {\n    this.ɵdir = /*@__PURE__*/i0.ɵɵdefineDirective({\n      type: HoverCardDirective,\n      selectors: [[\"\", \"appHoverCard\", \"\"]],\n      hostBindings: function HoverCardDirective_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"mouseenter\", function HoverCardDirective_mouseenter_HostBindingHandler($event) {\n            return ctx.onMouseEnter($event);\n          })(\"mousemove\", function HoverCardDirective_mousemove_HostBindingHandler($event) {\n            return ctx.onMouseMove($event);\n          })(\"mouseleave\", function HoverCardDirective_mouseleave_HostBindingHandler() {\n            return ctx.onMouseLeave();\n          });\n        }\n      },\n      inputs: {\n        hoverScale: \"hoverScale\",\n        hoverRotateX: \"hoverRotateX\",\n        hoverRotateY: \"hoverRotateY\",\n        transitionDuration: \"transitionDuration\",\n        perspective: \"perspective\",\n        shadowColor: \"shadowColor\"\n      }\n    });\n  }\n}","map":{"version":3,"mappings":"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","names":["HoverCardDirective","constructor","el","renderer","initialTransform","nativeElement","style","transform","initialTransition","transition","initialBoxShadow","boxShadow","setStyle","perspective","transitionDuration","onMouseEnter","event","rect","getBoundingClientRect","x","clientX","left","y","clientY","top","rotateY","width","rotateX","height","hoverScale","shadowColor","onMouseMove","onMouseLeave","selectors","hostBindings","ctx"],"sourceRoot":"","sources":["/home/yassine/Images/emna/job-checker-app/src/app/directives/hover-card.directive.ts"],"sourcesContent":["import { Directive, ElementRef, HostListener, Input, Renderer2 } from '@angular/core';\n\n@Directive({\n  selector: '[appHoverCard]'\n})\nexport class HoverCardDirective {\n  @Input() hoverScale: string = '1.02';\n  @Input() hoverRotateX: string = '0deg';\n  @Input() hoverRotateY: string = '0deg';\n  @Input() transitionDuration: string = '0.3s';\n  @Input() perspective: string = '1000px';\n  @Input() shadowColor: string = 'rgba(0, 0, 0, 0.1)';\n  \n  private initialTransform: string;\n  private initialTransition: string;\n  private initialBoxShadow: string;\n\n  constructor(\n    private el: ElementRef,\n    private renderer: Renderer2\n  ) {\n    // Store initial styles\n    this.initialTransform = this.el.nativeElement.style.transform || '';\n    this.initialTransition = this.el.nativeElement.style.transition || '';\n    this.initialBoxShadow = this.el.nativeElement.style.boxShadow || '';\n    \n    // Set initial perspective\n    this.renderer.setStyle(this.el.nativeElement, 'perspective', this.perspective);\n    this.renderer.setStyle(this.el.nativeElement, 'transition', `all ${this.transitionDuration} ease`);\n  }\n\n  @HostListener('mouseenter', ['$event'])\n  onMouseEnter(event: MouseEvent) {\n    // Calculate tilt based on mouse position\n    const rect = this.el.nativeElement.getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    const y = event.clientY - rect.top;\n    \n    // Calculate rotation (subtle effect)\n    const rotateY = ((x / rect.width) - 0.5) * 5; // -2.5 to 2.5 degrees\n    const rotateX = ((y / rect.height) - 0.5) * -5; // 2.5 to -2.5 degrees\n    \n    // Apply transform\n    this.renderer.setStyle(\n      this.el.nativeElement, \n      'transform', \n      `${this.initialTransform} scale(${this.hoverScale}) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`\n    );\n    \n    // Apply enhanced shadow\n    this.renderer.setStyle(\n      this.el.nativeElement,\n      'box-shadow',\n      `0 10px 25px -5px ${this.shadowColor}, 0 10px 10px -5px ${this.shadowColor}`\n    );\n  }\n\n  @HostListener('mousemove', ['$event'])\n  onMouseMove(event: MouseEvent) {\n    // Calculate tilt based on mouse position\n    const rect = this.el.nativeElement.getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    const y = event.clientY - rect.top;\n    \n    // Calculate rotation (subtle effect)\n    const rotateY = ((x / rect.width) - 0.5) * 5; // -2.5 to 2.5 degrees\n    const rotateX = ((y / rect.height) - 0.5) * -5; // 2.5 to -2.5 degrees\n    \n    // Apply transform\n    this.renderer.setStyle(\n      this.el.nativeElement, \n      'transform', \n      `${this.initialTransform} scale(${this.hoverScale}) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`\n    );\n  }\n\n  @HostListener('mouseleave')\n  onMouseLeave() {\n    // Reset transform\n    this.renderer.setStyle(this.el.nativeElement, 'transform', this.initialTransform);\n    \n    // Reset shadow\n    this.renderer.setStyle(this.el.nativeElement, 'box-shadow', this.initialBoxShadow);\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}